breed [sheep a-sheep]
breed [wolves wolf]
globals[ SizeOfMap wolves-in-position]

turtles-own [prev-xcor prev-ycor]


to set-globals
  set SizeOfMap (max-pxcor + 1)
  set wolves-in-position 0
end
to setup

  clear-all
  reset-ticks
  set-globals
   ask patches with [pxcor >= (- SizeOfMap) and pxcor < (SizeOfMap) and pycor >= (- SizeOfMap) and pycor < (SizeOfMap )]
    [ set pcolor scale-color green ((random 500) + 5000) 0 9000 ]

  set-default-shape sheep "sheep"

  create-sheep 1  ;; create the sheep
  [
    set color white
    set size 1  ;; easier to see
    setxy (round random-xcor) (round random-ycor)
    set heading 0
  ]

  set-default-shape wolves "wolf"

  create-wolves 4  ;; create the wolves
  [
    set color black
    set size 1  ;; easier to see
    setxy (round random-xcor) (round random-ycor)
    set heading 0
  ]
end


;;;
;;; Wolves own this characteristics
;;;
wolves-own [
  last-action
  desire
  intention
  plan
]


;;;
;;; Initialization of the wolf
;;;
to init-wolf
  set desire "catch"
  set intention build-empty-intention
  set plan build-empty-plan
  set last-action ""
end


;;;
;;;  Step up the simulation
;;;
to go
  ;Stoping condition test
  ask wolves [
    if around-sheep?[
      set wolves-in-position (wolves-in-position + 1)
    ]
  ]
  if wolves-in-position = 4[
    stop
  ]
  set wolves-in-position 0

  let collisions true
  tick
  ;; the wolves act
  ask wolves [
      set prev-xcor xcor
      set prev-ycor ycor
      wolf-loop
  ]
  ;; the sheep act
  ask sheep [
    set prev-xcor xcor
     set prev-ycor ycor
    set heading ((random 4) * 90)
    if (random 100) > 25 [
      fd 1
    ]
  ]
  ;;correct colisions
  while [collisions] [
    set collisions false
    ask turtles [
      if (count (turtles-on patch-here)) > 1[
        set collisions true
        ask (turtles-on patch-here)[
          backtrace-movements
        ]
      ]
    ]
  ]
end


;;;
;;;  wolf's updating procedure, which defines the rules of its behaviors
;;;
to wolf-loop
  set last-action ""
  ifelse not (empty-plan? plan or intention-succeeded? intention or impossible-intention? intention)
  [
    execute-plan-action
    update-beliefs
  ]
  [
    update-beliefs
    ;; Check the robot's options
    set desire BDI-options
    set intention BDI-filter
    set plan build-plan-for-intention intention

    ;; If it could not build a plan, the robot should behave as a reactive agent
    if(empty-plan? plan)
      [ reactive-agent-loop ]
  ]

end

;
;Returns the turtle to its previous position
;

to backtrace-movements
  set xcor prev-xcor
  set ycor prev-ycor
end

;
;Reports if an agent is next to a sheep
;
to-report around-sheep?
  report any? sheep-on neighbors4
end


;
;Reports the sheep if it is in the wolf's field of vision or nobody
;
to-report position-sheep
  ;let patches-seen patches with [(distance myself) < Wolf_depth_of_field]
  ;let sheep-found sheep-on patches-seen
  ;report one-of sheep-found

  report one-of sheep-on (patches in-radius Wolf_depth_of_field)
end


;;;
;;; According to the current beliefs, it selects the wolf's desires
;;;
;;; Reference: Chap.4 de [Wooldridge02]
;;;
to-report BDI-options

 report "catch"
end


;;;
;;; It selects a desire and coverts it into an intention
;;; Reference: Chap.4 de [Wooldridge02]
;;;
to-report BDI-filter
  report build-empty-intention
end


;;;
;;;  Create a plan for a given intention
;;;
to-report build-plan-for-intention [iintention]
  let new-plan 0

  set new-plan build-empty-plan

end



;;;
;;;  Update the wolf's beliefs based on its perceptions
;;;  Reference: Chap.4 of [Wooldridge02]
;;;
to update-beliefs
  update-state
end

;;;
;;;  Check if the robot's intention has been achieved
;;;
to-report intention-succeeded? [iintention]
  let ddesire 0


  if(empty-intention? iintention)
    [ report false ]

  set ddesire get-intention-desire iintention
  if(ddesire = "catch")
  [ report true]
end


;;;  Check if an intention cannot be achieved anymore
;;;
;;;
to-report impossible-intention? [iintention]
  report false
end


;;;
;;;  Reactive agent control loop
;;;
to reactive-agent-loop
   let the-sheep position-sheep
  if not around-sheep?[
    if the-sheep != nobody[
      face the-sheep
      set heading ( floor (heading / 90)) * 90
    ]
    fd 1
  ]

end



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;                                            ;;;
;;;           INTERNAL ABSTRACT TYPES          ;;;
;;;                                            ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;
;;; -------------------------
;;; Intention
;;;
;;; Chap.4 of [Wooldridge02]
;;; An intention is a list such as [desire position heading]
;;; -------------------------
;;;
to-report build-empty-intention
  report []
end

to-report empty-intention? [iintention]
  report empty? iintention
end

to-report get-intention-desire [iintention]
  report item 0 iintention
end


;;;
;;; -------------------------
;;;    Plans
;;; -------------------------
;;;
to-report build-empty-plan
  report []
end

to-report empty-plan? [pplan]
  report empty? pplan
end


;;;
;;; ----------------------------
;;;  Plan execution procedures
;;; ----------------------------
;;;

;;;
;;;  Execute the next action of the current plan
;;;
to execute-plan-action

end

;;;
;;; ----------------------------------------
;;;    Internal state updating procedures
;;; ----------------------------------------
;;;

;;;
;;;  Update the robot's state
;;;
to update-state
  let aux 0
end



